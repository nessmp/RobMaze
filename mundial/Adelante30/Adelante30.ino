#include <Wire.h> //Libreria para I2C
#include <Adafruit_MotorShield.h> //libreria del shield de los motores
#include "utility/Adafruit_MS_PWMServoDriver.h" //Shield de los motores
#include <SparkFunMLX90614.h> //libreria de los MLX
#include <Sharp.h> //libreria de los Sharps, duh
#include <ZX_Sensor.h> //Â¿Para los sensores ZX?
#include <Encoder.h> //para que crees...
#include <Servo.h> //Yep para el servo
#include "U8glib.h" //Oled

//Motores
Adafruit_MotorShield MotDerEnf = Adafruit_MotorShield(0x60); //Motor Derecha Enfrete
Adafruit_MotorShield MotDerAtr = Adafruit_MotorShield(0x60); //Motor Derecha Atras
Adafruit_DCMotor *MDE = MotDerEnf.getMotor(1); //Apuntador al motor de la derecha enfrente
Adafruit_DCMotor *MDA = MotDerAtr.getMotor(2); //Apuntador al motor de la derecha atras
Adafruit_MotorShield MotIzqEnf = Adafruit_MotorShield(0x60); //Motor Izquierda Enfrete
Adafruit_MotorShield MotIzqAtr = Adafruit_MotorShield(0x60); //Motor Izquierda Atras
Adafruit_DCMotor *MIE = MotIzqEnf.getMotor(3); //Apuntador al motor de la izquierda enfrente
Adafruit_DCMotor *MIA = MotIzqAtr.getMotor(4); //Apuntador al motor de la izquierda atras

//Encoder
Encoder EncDerE(18, 19); //Encoder en los pines 18 y 19

//MLX
IRTherm therm1; //Primer MLX
IRTherm therm2; //Segundo MLX

//Servo
Servo tiraKits; //objeto del servo

//Sensores ZX
ZX_Sensor ZXDer(0x10); //ZX de la Der con I2C address 0x10
ZX_Sensor ZXIzq(0x11); //ZX de la Izq con I2C address 0x11

//Sharps
Sharp SharpDerEnf(0, 30); //Sharp de la Derecha Enf en el pin 0 con dist 30
Sharp SharpDerAtr(1, 30); //Sharp de la Derecha Atr en el pin 1 con dist 30
Sharp SharpIzqEnf(2, 30); //Sharp de la Izquierda Enf en el pin 2 con dist 30
Sharp SharpIzqAtr(3, 30); //Sharp de la Izquierda Atr en el pin 3 con dist 30

//Oled
U8GLIB_SH1106_128X64 u8g(U8G_I2C_OPT_NO_ACK);  //Objeto para la OLED

byte velMDE = 60; //velocidad para el motor de la derecha enfrente
byte velMDA = 200; //velocidad para el motor de la derecha atras
byte velMIE = 65; //velocidad para el motor de la izquierda enfrente
byte velMIA = 200; //velocidad para el motor de la izquierda atras

byte CalibCalor = 27; //Temperatura a detectar victimas

int const30 = 2000; //constante de los encoders

//Mapa de bits del Kit Medico
const unsigned char PROGMEM KitMedico [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xE0, 0x70, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xE0, 0x70, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xE0, 0x70, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x7F, 0xE0, 0x7F, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x7F, 0xE0, 0x7F, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x7F, 0xE0, 0x7F, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x78, 0x00, 0x01, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x70, 0x00, 0x00, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x70, 0x00, 0x00, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x70, 0x00, 0x00, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x70, 0x00, 0x00, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x78, 0x00, 0x01, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x7F, 0xE0, 0x7F, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x7F, 0xE0, 0x7F, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x7F, 0xE0, 0x7F, 0xE0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xE0, 0x70, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xE0, 0x70, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xE0, 0x70, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void setup() {
  Serial.begin(9600);

  tiraKits.attach(8); //Servo al pin 8

  ZXDer.init(); //Inicializa el bus del I2C para los sensores ZX
  ZXIzq.init();

  MotDerEnf.begin(); //inicializa el bus del I2C para los motores
  MotDerAtr.begin();
  MotIzqEnf.begin();
  MotIzqAtr.begin();

  MDE->run(RELEASE); //Apaga los motores, por seguridad
  MDA->run(RELEASE);
  MIE->run(RELEASE);
  MIA->run(RELEASE);

  u8g.setColorIndex(255); //Color OLED
}

//Faltan estas funciones que se usan en la funcion de adelante30
bool ParedDer() {}
bool ParedIzq() {}
bool ParedEnf() {}
bool BotellaDer() {}
bool BotellaIzq() {}

//Funcion que pone a los motores para avanzar
void Adelante()
{
  MDE->run(FORWARD);
  MDA->run(FORWARD);
  MIE->run(FORWARD);
  MIA->run(FORWARD);

  MDE->setSpeed(velMDE);
  MDA->setSpeed(velMDA);
  MIE->setSpeed(velMIE);
  MIA->setSpeed(velMIA);
}

//Funcion que detiene los motores
void Detenerse()
{
  MDE->run(RELEASE);
  MDA->run(RELEASE);
  MIE->run(RELEASE);
  MIA->run(RELEASE);
}

//Dinuja el Kit en la OLED
void drawKit()
{
  u8g.drawBitmapP( 0, 0, 16, 64, KitMedico);
}

//Escribe Victima
void drawVictima()
{
  u8g.setFont(u8g_font_osb21);
  u8g.drawStr( 0, 22, "Victima");
}

//Escribe Detectada
void drawDetectada()
{
  u8g.setFont(u8g_font_osb21);
  u8g.drawStr( 0, 22, "Detectada");
}

//Dibuja kit y escribe victima detectada en OLED
void Victima()
{
  u8g.firstPage();
  do {
    drawKit();
  } while ( u8g.nextPage() );
  delay(1000);
  u8g.firstPage();
  do {
    drawVictima();
  } while ( u8g.nextPage() );
  delay(500);
  u8g.firstPage();
  do {
    drawDetectada();
  } while ( u8g.nextPage() );
  delay(500);
}

//Funcion que detecta si hay victima
void Detectar()
{
  therm1.read(); //comienza lecturas del primer MLX
  therm2.read(); //comienza lecturas del segundo MLX

  int Therm1 = therm1.object(); //Lectura del objeto al cual apunta los MLX
  int Therm2 = therm2.object();
  /*
     Falta programacion para indicar en la OLED que se detecto una victima
  */
  int pos = tiraKits.read();
  if (Therm1 > CalibCalor)
  {
    Detenerse(); //Se detiene antes de dispensar kit
    while (pos != 90) //Se mueve para tomar un kit
    {
      tiraKits.write(90);
      pos = tiraKits.read();
    }
    Victima(); //Indica la victima en la OLED
    while (pos != 0) //Se mueve para tirar el kit
    {
      tiraKits.write(0);
      pos = tiraKits.read();
    }
  }
  else if (Therm2 > CalibCalor)
  {
    Detenerse(); //Se detiene antes de dispensar kit
    while (pos != 90) //Se mueve para tomar un kit
    {
      tiraKits.write(90);
      pos = tiraKits.read();
    }
    Victima(); //Indica la victima en la OLED
    while (pos != 180) //Se mueve para tirar el kit
    {
      tiraKits.write(180);
      pos = tiraKits.read();
    }
  }
  while (pos != 90) //Se mueve para tomar un kit
  {
    tiraKits.write(90);
    pos = tiraKits.read();
  }
}

//funcion que avanza 10 cm
void Adelante10()
{
  EncDerE.write(0); //Inicia la cuenta de los encoders en 0
  int Enc = EncDerE.read(); //Primer lectura de los encoders, debe ser 0
  int const10 = const30 / 3; //Divide entre 3 la const 30
  Adelante(); //Comienza movimiento
  while (Enc < const10) //Mientras la lectura del encoder sea menor a la const sigue moviendose
  {
    Enc = EncDerE.read(); //lectura del encoder para salir del loop
  }
  Detenerse(); //Acaba Mov
}

//funcion para moverse 30 cm
void Adelante30()
{
  bool ProxPD = false; //Pared a la der despues de haber avanzado 30
  bool ProxPI = false; //Pared a la izq despues de haber avanzado 30
  bool inicioPD = ParedDer(); //Saber si al inicio hay pared a la derecha
  bool inicioPI = ParedIzq(); //Saber si al inicio hay pared a la izquierda
  Detectar(); //Detecta si hay victima
  Adelante10(); //Se mueve 10 cm
  byte ShD = SharpDerEnf.distance(); //Distancia detectada por el Sharp de la Derecha Enfrente
  if (ShD < 20) //Si la distancia es menor a 20 se espera una pared despues de moverse 30 cm
  {
    ProxPD = true;
  }
  byte ShI = SharpIzqEnf.distance(); //Distancia detectada por el Sharp de la Izquierda Enfrente
  if (ShI < 20) //Si la distancia es menor a 20 se espera una pared despues de moverse 30 cm
  {
    ProxPI = true;
  }
  Detectar(); //Detecta si hay victima
  Adelante10(); //Se mueve 10 cm
  ShD = SharpDerEnf.distance(); //Distancia detectada por el Sharp de la Derecha Enfrente
  if (ShD < 20) //Si la distancia es menor a 20 se espera una pared despues de moverse 30 cm
  {
    ProxPD = true;
  }
  ShI = SharpIzqEnf.distance(); //Distancia detectada por el Sharp de la Izquierda Enfrente
  if (ShI < 20) //Si la distancia es menor a 20 se espera una pared despues de moverse 30 cm
  {
    ProxPI = true;
  }
  Detectar(); //Detecta si hay victima
  Adelante10(); //Se mueve 10 cm
  bool finalPD = ParedDer(); //Saber si al final hay pared a la derecha
  bool finalPI = ParedIzq(); //Saber si al final hay pared a la izquierda
  if (finalPD != ProxPD) //Si la pared esperada no es igual a la actual se hace correccion
  {
    if (true == ProxPD) //Si se esperaba que hubiera pared
    {
      if (!BotellaDer()) //Se verifica no haberse equivocado al detectar una botella como pared
      {
        do {
          Adelante10();
          finalPD = ParedDer();
        } while (true != finalPD); //Avanza de 10cm en 10 cm hasta encontrar la pared
      }
    }
    else //En caso que no se esperara pared
    {
      do {
        Adelante10();
        finalPD = ParedDer();
      } while (false != finalPD); //Se avanza hasta no detectar pared
    }
  }
  if (finalPI != ProxPI) //Si la pared esperada no es igual a la actual se hace correccion
  {
    if (true == ProxPI) //Si se esperaba que hubiera pared
    {
      if (!BotellaIzq()) //Se verifica no haberse equivocado al detectar una botella como pared
      {
        do {
          Adelante10();
          finalPI = ParedIzq();
        } while (true != finalPI); //Avanza de 10cm en 10 cm hasta encontrar la pared
      }
    }
    else //En caso que no se esperara pared
    {
      do {
        Adelante10();
        finalPI = ParedIzq();
      } while (false != finalPI); //Se avanza hasta no detectar pared
    }
  }
  Detectar(); //Detecta si hay victima
  Detenerse(); //Termina mov de 30 cm
}

void loop() {
  Victima();
}
